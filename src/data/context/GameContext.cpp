#include "GameContext.hh"

#include "Exports.hh"

#include "RA_Defs.h"
#include "RA_md5factory.h"
#include "util\Log.hh"
#include "util\Strings.hh"

#include "context\IConsoleContext.hh"
#include "context\IRcClient.hh"
#include "context\UserContext.hh"

#include "data\context\EmulatorContext.hh"
#include "data\context\SessionTracker.hh"

#include "data\models\AchievementModel.hh"
#include "data\models\CodeNotesModel.hh"
#include "data\models\LocalBadgesModel.hh"
#include "data\models\RichPresenceModel.hh"

#include "services\AchievementRuntime.hh"
#include "services\FrameEventQueue.hh"
#include "services\IAudioSystem.hh"
#include "services\IConfiguration.hh"
#include "services\ILocalStorage.hh"
#include "services\impl\FileTextReader.hh"
#include "services\impl\FileTextWriter.hh"
#include "services\impl\StringTextReader.hh"

#include "ui\ImageReference.hh"

#include "ui\viewmodels\MessageBoxViewModel.hh"
#include "ui\viewmodels\OverlayManager.hh"
#include "ui\viewmodels\ScoreboardViewModel.hh"
#include "ui\viewmodels\WindowManager.hh"

#include <rcheevos\src\rc_client_internal.h>
#include <rcheevos\include\rc_api_runtime.h>

namespace ra {
namespace data {
namespace context {

static bool ValidateConsole(int nServerConsoleId)
{
    const auto& pConsoleContext = ra::services::ServiceLocator::Get<ra::context::IConsoleContext>();
    if (ra::etoi(pConsoleContext.Id()) != nServerConsoleId)
    {
        switch (nServerConsoleId)
        {
            case RC_CONSOLE_GAMEBOY:
                // GB memory map is just a subset of GBC, and GBC runs GB games, so allow loading a
                // GB game in GBC context.
                if (pConsoleContext.Id() == ra::etoi(ConsoleID::GBC))
                    return true;

                break;

            case RC_CONSOLE_NINTENDO_DS:
                // DS memory map is just a subset of DSi, and DSi runs DS games, so allow loading a
                // DS game in DSi context.
                if (pConsoleContext.Id() == ra::etoi(ConsoleID::DSi))
                    return true;

                break;

            case RC_CONSOLE_NINTENDO:
            case RC_CONSOLE_FAMICOM_DISK_SYSTEM:
                // FDS used to be part of the NES library.
                // Allow loading FDS titles in NES mode to ease the transition.
                if (pConsoleContext.Id() == ra::etoi(ConsoleID::NES) ||
                    pConsoleContext.Id() == ra::etoi(ConsoleID::FamicomDiskSystem))
                    return true;

                break;

            case RC_CONSOLE_EVENTS:
            case RC_CONSOLE_STANDALONE:
                // Hashes for Events and Standalone games are generated by modifying an existing ROM in
                // a very specific manner. To generate the correct hash, Events and Standalone games are
                // loaded through the console associated to the unmodified ROM and therefore will never
                // match the console context.
                return true;

            default:
                break;
        }

        ra::ui::viewmodels::MessageBoxViewModel::ShowErrorMessage(
            L"Identified game does not match expected console.",
            ra::util::String::Printf(
                L"The game being loaded is associated to the %s console, but the emulator has initialized "
                "the %s console. This is not allowed as the memory maps may not be compatible between "
                "consoles.",
                rc_console_name(nServerConsoleId), pConsoleContext.Name()));

        return false;
    }

    return true;
}

bool GameContext::BeginLoadGame(unsigned int nGameId, Mode nMode, bool& bWasPaused)
{
    OnBeforeActiveGameChanged();

    // remove the current asset from the asset editor
    auto& vmWindowManager = ra::services::ServiceLocator::GetMutable<ra::ui::viewmodels::WindowManager>();
    vmWindowManager.AssetEditor.LoadAsset(nullptr, true);

    // reset the runtime
    auto& pRuntime = ra::services::ServiceLocator::GetMutable<ra::services::AchievementRuntime>();
    pRuntime.ResetRuntime();

    // reset the GameContext
    m_nMode = nMode;
    m_sGameTitle.clear();
    m_vSubsets.clear();
    m_vAssets.ResetLocalId();

    m_vAssets.BeginUpdate();

    m_vAssets.Clear();

    // if not loading a game, finish up and return
    if (nGameId == 0)
    {
        m_vAssets.EndUpdate();

        m_sGameHash.clear();
        m_nActiveGameId = 0;

        if (m_nGameId != 0)
        {
            m_nGameId = 0;

            auto* pClient = ra::services::ServiceLocator::Get<ra::context::IRcClient>().GetClient();
            rc_client_unload_game(pClient);

            OnActiveGameChanged();
        }
        return false;
    }

    // start the load process
    BeginLoad();
    m_nGameId = m_nActiveGameId = GetRealGameId(nGameId);

    // create a model for managing badges
    auto pLocalBadges = std::make_unique<ra::data::models::LocalBadgesModel>();
    pLocalBadges->CreateServerCheckpoint();
    pLocalBadges->CreateLocalCheckpoint();
    m_vAssets.Append(std::move(pLocalBadges));

    bWasPaused = pRuntime.IsPaused();
    pRuntime.SetPaused(true);

    return true;
}

void GameContext::LoadGame(unsigned int nGameId, const std::string& sGameHash, Mode nMode)
{
    bool bWasPaused;

    if (!BeginLoadGame(nGameId, nMode, bWasPaused))
        return;

    // download the game data
    struct LoadGameUserData
    {
        bool bWasPaused = false;
    }* pLoadGameUserData;
    pLoadGameUserData = new LoadGameUserData;
    pLoadGameUserData->bWasPaused = bWasPaused;

    auto& pRuntime = ra::services::ServiceLocator::GetMutable<ra::services::AchievementRuntime>();
    pRuntime.BeginLoadGame(sGameHash, nGameId,
        [](int nResult, const char* sErrorMessage, rc_client_t*, void* pUserdata) {
            auto& pGameContext = ra::services::ServiceLocator::GetMutable<ra::data::context::GameContext>();
            auto* pLoadGameUserData = static_cast<struct LoadGameUserData*>(pUserdata);
            pGameContext.FinishLoadGame(nResult, sErrorMessage, pLoadGameUserData->bWasPaused);
            delete pLoadGameUserData;
        },
        pLoadGameUserData);
}

void GameContext::FinishLoadGame(int nResult, const char* sErrorMessage, bool bWasPaused)
{
    if (nResult != RC_OK)
    {
        m_nGameId = 0;

        ra::ui::viewmodels::MessageBoxViewModel::ShowErrorMessage(L"Failed to load game data",
                                                                    ra::util::String::Widen(sErrorMessage));
    }
    else
    {
        const auto* pClient = ra::services::ServiceLocator::Get<ra::context::IRcClient>().GetClient();
        const auto* pGame = rc_client_get_game_info(pClient);
        if (pGame == nullptr || pGame->id == 0)
        {
            // invalid hash
            m_nGameId = m_nActiveGameId = 0;
            m_sGameTitle.clear();
            m_sGameHash.clear();
            nResult = RC_NO_GAME_LOADED;
        }
        else if (!ValidateConsole(pGame->console_id))
        {
            m_nGameId = m_nActiveGameId = 0;
            m_sGameTitle.clear();
            m_sGameHash.clear();
            nResult = RC_INVALID_STATE;
        }
        else
        {
            rc_client_user_game_summary_t pSummary;
            rc_client_get_user_game_summary(pClient, &pSummary);

            // show "game loaded" popup
            ra::services::ServiceLocator::Get<ra::services::IAudioSystem>().PlayAudioFile(L"Overlay\\info.wav");
            std::wstring sDescription = ra::util::String::Printf(L"%u achievements, %u points",
                                                            pSummary.num_core_achievements, pSummary.points_core);
            if (pSummary.num_unsupported_achievements)
                sDescription += ra::util::String::Printf(L" (%u unsupported)", pSummary.num_unsupported_achievements);

            ra::services::ServiceLocator::GetMutable<ra::ui::viewmodels::OverlayManager>().QueueMessage(
                ra::util::String::Printf(L"Loaded %s", pGame->title), sDescription,
                ra::util::String::Printf(L"You have earned %u achievements", pSummary.num_unlocked_achievements),
                ra::ui::ImageType::Icon, pGame->badge_name);
        }
    }

    EndLoadGame(nResult, bWasPaused, true);
}

void GameContext::EndLoadGame(int nResult, bool bWasPaused, bool bShowSoftcoreWarning)
{
    {
        ra::data::models::RichPresenceModel* pRichPresence = nullptr;
        std::string sOldRichPresence;
        const auto nGameId = m_nGameId;

        std::lock_guard<std::mutex> lock(m_mLoadMutex);

        if (m_nGameId != nGameId)
            return;

        if (nResult == RC_OK && m_nGameId > 0)
        {
            BeginLoad();

            auto pCodeNotes = std::make_unique<ra::data::models::CodeNotesModel>();
            pCodeNotes->Refresh(
                m_nGameId,
                [this](ra::data::ByteAddress nAddress, const std::wstring& sNewNote) {
                    OnCodeNoteChanged(nAddress, sNewNote);
                },
                [this](ra::data::ByteAddress nOldAddress, ra::data::ByteAddress nNewAddress, const std::wstring sNote) {
                    OnCodeNoteMoved(nOldAddress, nNewAddress, sNote);
                },
                [this]() {
                    EndLoad();
                });

            m_vAssets.Append(std::move(pCodeNotes));

            // the old server value (if different from current server value) will be stored as Local modification.
            // capture it now. ReloadAssets will load the XXX-Rich.txt file and replace it
            pRichPresence = m_vAssets.FindRichPresence();
            if (pRichPresence)
                sOldRichPresence = pRichPresence->GetScript();

            // merge local assets
            std::vector<ra::data::models::AssetModelBase*> vEmptyAssetsList;
            m_vAssets.ReloadAssets(vEmptyAssetsList);
        }

        if (!bWasPaused)
        {
            ra::services::ServiceLocator::GetMutable<ra::services::AchievementRuntime>().SetPaused(false);
#ifndef RA_UTEST
            auto& pAssetList = ra::services::ServiceLocator::GetMutable<ra::ui::viewmodels::WindowManager>().AssetList;
            pAssetList.SetProcessingActive(true);
#endif
        }

        // activate rich presence (or remove if not defined)
        if (pRichPresence && nResult == RC_OK)
        {
            pRichPresence->SetSubsetID(m_vSubsets.front().AchievementSetID());

            // if the server value differs from the local value, the model will appear as Unpublished
            if (pRichPresence->GetChanges() != ra::data::models::AssetChanges::None)
            {
                // populate another model with the old script so the string gets normalized correctly
                ra::data::models::RichPresenceModel pOldRichPresenceModel;
                pOldRichPresenceModel.SetScript(sOldRichPresence);

                // if the old value matches the current value, then the value on the server changed and
                // there are no local modifications. revert to the server state.
                if (pRichPresence->GetScript() == pOldRichPresenceModel.GetScript())
                    pRichPresence->RestoreServerCheckpoint();
            }

            if (pRichPresence->GetScript().empty() &&
                pRichPresence->GetChanges() == ra::data::models::AssetChanges::None)
            {
                const auto nIndex = m_vAssets.FindItemIndex(ra::data::models::AssetModelBase::TypeProperty,
                                                            ra::etoi(ra::data::models::AssetType::RichPresence));
                m_vAssets.RemoveAt(nIndex);
            }
            else
            {
                pRichPresence->Activate();
            }
        }

        // modified assets should start in the inactive state
        size_t nLocalAssets = 0;
        for (auto& pAsset : m_vAssets)
        {
            if (pAsset.GetChanges() != ra::data::models::AssetChanges::None)
            {
                if (pAsset.HasUnpublishedChanges())
                    ++nLocalAssets;

                if (pAsset.IsActive())
                {
                    if (pAsset.GetType() == ra::data::models::AssetType::RichPresence &&
                        ra::services::ServiceLocator::Get<ra::ui::viewmodels::WindowManager>()
                            .RichPresenceMonitor.IsVisible())
                    {
                        // if rich presence monitor is open, allow modified rich presence to remain active. otherwise,
                        // it will be activated when the monitor is opened. it cannot be activated from the list.
                        continue;
                    }

                    pAsset.SetState(ra::data::models::AssetState::Inactive);
                }
            }
        }
        if (nLocalAssets > 0)
        {
            RA_LOG_INFO("%d unpublished assets loaded", nLocalAssets);
        }

        // finish up
        m_vAssets.EndUpdate();

        auto& pRuntime = ra::services::ServiceLocator::GetMutable<ra::services::AchievementRuntime>();
        pRuntime.SyncAssets();

        EndLoad();
    }

    // non-hardcore warning
    auto& pConfiguration = ra::services::ServiceLocator::Get<ra::services::IConfiguration>();
    if (!pConfiguration.IsFeatureEnabled(ra::services::Feature::Hardcore))
    {
        bool bShowHardcorePrompt = false;
        if (pConfiguration.IsFeatureEnabled(ra::services::Feature::NonHardcoreWarning))
            bShowHardcorePrompt = Assets().HasCoreAssets();

        if (bShowHardcorePrompt)
        {
            ra::ui::viewmodels::MessageBoxViewModel vmWarning;
            vmWarning.SetHeader(L"Enable Hardcore mode?");
            vmWarning.SetMessage(
                L"You are loading a game with achievements and do not currently have hardcore mode enabled.");
            vmWarning.SetIcon(ra::ui::viewmodels::MessageBoxViewModel::Icon::Warning);
            vmWarning.SetButtons(ra::ui::viewmodels::MessageBoxViewModel::Buttons::YesNo);

            if (vmWarning.ShowModal() == ra::ui::DialogResult::Yes)
                ra::services::ServiceLocator::GetMutable<ra::data::context::EmulatorContext>().EnableHardcoreMode(false);
        }
        else if (bShowSoftcoreWarning)
        {
            const bool bLeaderboardsEnabled = pConfiguration.IsFeatureEnabled(ra::services::Feature::Leaderboards);

            ra::services::ServiceLocator::Get<ra::services::IAudioSystem>().PlayAudioFile(L"Overlay\\info.wav");
            ra::services::ServiceLocator::GetMutable<ra::ui::viewmodels::OverlayManager>().QueueMessage(
                L"Playing in Softcore Mode",
                bLeaderboardsEnabled ? L"Leaderboard entries will not be submitted." : L"");
        }
    }

    OnActiveGameChanged();
}

void GameContext::InitializeFromAchievementRuntime(const std::map<uint32_t, std::string> mAchievementDefinitions,
                                                   const std::map<uint32_t, std::string> mLeaderboardDefinitions)
{
    auto* pClient = ra::services::ServiceLocator::Get<ra::context::IRcClient>().GetClient();
    const auto* pGame = rc_client_get_game_info(pClient);
    m_nGameId = GetRealGameId(pGame->id);
    m_sGameTitle = ra::util::String::Widen(pGame->title);
    m_sGameHash = pGame->hash ? pGame->hash : "";

#ifndef RA_UTEST
    auto& pImageRepository = ra::services::ServiceLocator::GetMutable<ra::ui::IImageRepository>();
#endif

    std::lock_guard<std::mutex> lock(m_mLoadMutex);

    for (auto* pSubset = pClient->game->subsets; pSubset; pSubset = pSubset->next)
    {
        // achievements
        auto* pAchievementData = pSubset->achievements;
        if (pAchievementData != nullptr)
        {
            const auto* pAchievementStop = pAchievementData + pSubset->public_.num_achievements;
            for (; pAchievementData < pAchievementStop; ++pAchievementData)
            {
                // if the server has provided an unexpected category (usually 0), ignore it.
                ra::data::models::AssetCategory nCategory = ra::data::models::AssetCategory::None;
                switch (pAchievementData->public_.category)
                {
                    case RC_CLIENT_ACHIEVEMENT_CATEGORY_CORE:
                        nCategory = ra::data::models::AssetCategory::Core;

                        // automatically activate all core achievements in compatibility mode
                        if (GetMode() == Mode::CompatibilityTest)
                        {
                            pAchievementData->public_.state = RC_CLIENT_ACHIEVEMENT_STATE_ACTIVE;

                            if (pAchievementData->trigger)
                                pAchievementData->trigger->state = RC_TRIGGER_STATE_WAITING;
                        }
                        break;

                    case RC_CLIENT_ACHIEVEMENT_CATEGORY_UNOFFICIAL:
                        nCategory = ra::data::models::AssetCategory::Unofficial;

                        // all unofficial achievements should start inactive.
                        // rc_client automatically activates them.
                        pAchievementData->public_.state = RC_CLIENT_ACHIEVEMENT_STATE_INACTIVE;

                        if (pAchievementData->trigger)
                            pAchievementData->trigger->state = RC_TRIGGER_STATE_INACTIVE;
                        break;

                    default:
                        continue;
                }

                auto vmAchievement = std::make_unique<ra::data::models::AchievementModel>();

                const auto sDefinition = mAchievementDefinitions.find(pAchievementData->public_.id);
                if (sDefinition != mAchievementDefinitions.end())
                    vmAchievement->Attach(*pAchievementData, nCategory, sDefinition->second);
                else
                    vmAchievement->Attach(*pAchievementData, nCategory, "");

                vmAchievement->SetSubsetID(pSubset->public_.id);

                m_vAssets.Append(std::move(vmAchievement));

#ifndef RA_UTEST
                // prefetch the achievement image
                pImageRepository.FetchImage(ra::ui::ImageType::Badge, pAchievementData->public_.badge_name,
                    pAchievementData->public_.badge_url ? pAchievementData->public_.badge_url : "");

                if (!pAchievementData->public_.unlocked)
                {
                    pImageRepository.FetchImage(ra::ui::ImageType::Badge,
                        std::string(pAchievementData->public_.badge_name) + "_lock",
                        pAchievementData->public_.badge_locked_url ? pAchievementData->public_.badge_locked_url : "");
                }
#endif
            }
        }

        // leaderboards
        auto* pLeaderboardData = pSubset->leaderboards;
        if (pLeaderboardData != nullptr)
        {
            const auto* pLeaderboardStop = pLeaderboardData + pSubset->public_.num_leaderboards;
            for (; pLeaderboardData < pLeaderboardStop; ++pLeaderboardData)
            {
                auto vmLeaderboard = std::make_unique<ra::data::models::LeaderboardModel>();

                const auto nCategory = ra::data::models::AssetCategory::Core; // all published leaderboards are core

                const auto sDefinition = mLeaderboardDefinitions.find(pLeaderboardData->public_.id);
                if (sDefinition != mLeaderboardDefinitions.end())
                    vmLeaderboard->Attach(*pLeaderboardData, nCategory, sDefinition->second);
                else
                    vmLeaderboard->Attach(*pLeaderboardData, nCategory, "");

                vmLeaderboard->SetSubsetID(pSubset->public_.id);

                m_vAssets.Append(std::move(vmLeaderboard));
            }
        }
    }
}

void GameContext::InitializeSubsets(const rc_api_fetch_game_sets_response_t* game_data_response)
{
    Expects(game_data_response != nullptr);

    std::lock_guard<std::mutex> lock(m_mLoadMutex);
    m_vSubsets.clear();

    // GameID dictates which game is loaded for purposes of local achievement storage and code notes
    m_nGameId = GetRealGameId(game_data_response->id);
    // ActiveGameID dictates which game is running for purposes of rich presence and pings
    const auto nActiveGameId = GetRealGameId(game_data_response->session_game_id);
    if (m_nActiveGameId != nActiveGameId)
    {
        m_nActiveGameId = nActiveGameId;
        ra::services::ServiceLocator::GetMutable<ra::data::context::SessionTracker>().BeginSession(nActiveGameId);
    }

    for (uint32_t i = 0; i < game_data_response->num_sets; ++i)
    {
        const auto* pSet = &game_data_response->sets[i];
        if (pSet->type == RC_ACHIEVEMENT_SET_TYPE_CORE)
        {
            // core subset should always be first
            m_vSubsets.insert(m_vSubsets.begin(),
                              Subset(pSet->id, GetRealGameId(pSet->game_id),
                                     ra::util::String::Widen(pSet->title), SubsetType::Core));
        }
        else
        {
            SubsetType nType = SubsetType::Bonus;
            switch (pSet->type)
            {
                case RC_ACHIEVEMENT_SET_TYPE_EXCLUSIVE:
                    nType = SubsetType::Exclusive;
                    break;
                case RC_ACHIEVEMENT_SET_TYPE_SPECIALTY:
                    nType = SubsetType::Specialty;
                    break;
                default:
                    nType = SubsetType::Bonus;
                    break;
            }
            m_vSubsets.emplace_back(pSet->id, GetRealGameId(pSet->game_id),
                                    ra::util::String::Widen(pSet->title), nType);
        }
    }

    // if subsets were found, migrate any SUBSET-User.txt files into the the GAME-User.txt file
    if (m_vSubsets.size() > 1)
    {
        MigrateSubsetUserFiles();
    }
    else if (m_nActiveGameId != m_nGameId)
    {
        m_vSubsets.front().SetTitle(ra::util::String::Printf(L"%s (%s)",
            m_vSubsets.front().Title(), game_data_response->title));
    }
}

void GameContext::MigrateSubsetUserFiles()
{
    auto& pLocalStorage = ra::services::ServiceLocator::GetMutable<ra::services::ILocalStorage>();
    std::unique_ptr<ra::services::TextWriter> pGameData;

    for (size_t i = 1; i < m_vSubsets.size(); ++i)
    {
        const auto& pSubset = m_vSubsets.at(i);
        Expects(pSubset.GameID() != m_nGameId);

        auto pSubsetData = pLocalStorage.ReadText(ra::services::StorageItemType::UserAchievements,
                                                  std::to_wstring(pSubset.GameID()));
        if (pSubsetData)
        {
            // replace ID with "0|SUBSETID" so new IDs will be generated
            std::string sSubsetReplace = "0|" + std::to_string(pSubset.AchievementSetID());

            if (!pGameData)
            {
                pGameData = pLocalStorage.AppendText(ra::services::StorageItemType::UserAchievements,
                                                     std::to_wstring(m_nGameId));
                if (!pGameData)
                {
                    RA_LOG_ERR("Could not append to %u-User.txt", m_nGameId);
                    break;
                }
            }

            std::string sLine;
            pSubsetData->GetLine(sLine); // version
            pSubsetData->GetLine(sLine); // game name
            while (pSubsetData->GetLine(sLine))
            {
                if (!sLine.empty())
                {
                    if (isdigit(sLine.at(0)) || sLine.at(0) == 'L')
                    {
                        // found a local achievement or leaderboard. inject subset id
                        const auto nIndex = sLine.find(':');
                        if (nIndex != std::string::npos && nIndex > 8)
                        {
                            if (sLine.at(0) == 'L')
                                sLine.replace(1, nIndex - 1, sSubsetReplace);
                            else
                                sLine.replace(0, nIndex, sSubsetReplace);
                        }
                    }
                    else if (sLine.at(0) == 'N')
                    {
                        // found a note, just copy it over
                    }
                    else
                    {
                        // unexpected. ignore
                        continue;
                    }
                }

                pGameData->WriteLine(sLine);
            }

            // release the file so it can be deleted, then delete it.
            pSubsetData.reset();
            pLocalStorage.Delete(ra::services::StorageItemType::UserAchievements,
                                 std::to_wstring(pSubset.GameID()));
        }
    }
}

uint32_t GameContext::GetGameId(uint32_t nSubsetId) const noexcept
{
    for (const auto& pSubset : m_vSubsets)
    {
        if (pSubset.ID() == nSubsetId)
            return pSubset.GameID();
    }

    return GameId();
}

void GameContext::OnBeforeActiveGameChanged()
{
    if (m_vNotifyTargets.LockIfNotEmpty())
    {
        for (auto& target : m_vNotifyTargets.Targets())
            target.OnBeforeActiveGameChanged();

        m_vNotifyTargets.Unlock();
    }
}

void GameContext::OnActiveGameChanged()
{
    if (m_vNotifyTargets.LockIfNotEmpty())
    {
        for (auto& target : m_vNotifyTargets.Targets())
            target.OnActiveGameChanged();

        m_vNotifyTargets.Unlock();
    }
}

void GameContext::BeginLoad()
{
    if (m_nLoadCount.fetch_add(1) == 0)
    {
        if (m_vNotifyTargets.LockIfNotEmpty())
        {
            for (auto& target : m_vNotifyTargets.Targets())
                target.OnBeginGameLoad();

            m_vNotifyTargets.Unlock();
        }
    }
}

void GameContext::EndLoad()
{
    if (m_nLoadCount.fetch_sub(1) == 1)
    {
        for (auto& pAsset : m_vAssets)
            pAsset.Validate();

        if (m_vNotifyTargets.LockIfNotEmpty())
        {
            for (auto& target : m_vNotifyTargets.Targets())
                target.OnEndGameLoad();

            m_vNotifyTargets.Unlock();
        }
    }
}

void GameContext::DoFrame()
{
    std::lock_guard<std::mutex> lock(m_mLoadMutex);

    for (auto& pAsset : m_vAssets)
        pAsset.DoFrame();
}

void GameContext::OnCodeNoteChanged(ra::data::ByteAddress nAddress, const std::wstring& sNewNote)
{
    if (m_vNotifyTargets.LockIfNotEmpty())
    {
        if (!IsGameLoading())
        {
            for (auto& target : m_vNotifyTargets.Targets())
                target.OnCodeNoteChanged(nAddress, sNewNote);
        }

        m_vNotifyTargets.Unlock();
    }
}

void GameContext::OnCodeNoteMoved(ra::data::ByteAddress nOldAddress, ra::data::ByteAddress nNewAddress, const std::wstring& sNote)
{
    if (m_vNotifyTargets.LockIfNotEmpty())
    {
        if (!IsGameLoading())
        {
            for (auto& target : m_vNotifyTargets.Targets())
                target.OnCodeNoteMoved(nOldAddress, nNewAddress, sNote);
        }

        m_vNotifyTargets.Unlock();
    }
}

} // namespace context
} // namespace data
} // namespace ra
