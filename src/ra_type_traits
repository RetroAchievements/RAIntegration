#ifndef RA_TYPE_TRAITS_H
#define RA_TYPE_TRAITS_H
#pragma once

#include <ciso646>
#include <xmemory0>

#if _HAS_CXX17
#ifndef _CONSTANT_VAR
#define _CONSTANT_VAR inline constexpr auto
#endif // !_CONSTANT_VAR
#else
#ifndef _CONSTANT_VAR
#define _CONSTANT_VAR constexpr auto
#endif // !_CONSTANT_VAR
#endif // _HAS_CXX17

namespace ra {
namespace detail {

// sure it's here, we'll just erase the one in RA_Defs.h if it's ever merged
template<typename EqualityComparable, class = std::void_t<>>
struct is_equality_comparable : std::false_type {};

template<typename EqualityComparable>
struct is_equality_comparable<EqualityComparable, std::enable_if_t<std::is_convertible_v<
	decltype(std::declval<EqualityComparable&>() == std::declval<EqualityComparable&>()), bool>>> :
	std::true_type {};

template<typename EqualityComparable>
struct is_nothrow_equality_comparable :
	std::bool_constant<noexcept(is_equality_comparable<EqualityComparable>::value)>
{
};

template<typename T, class = std::void_t<>>
struct is_lessthan_comparable : std::false_type {};

template<typename T>
struct is_lessthan_comparable<T, std::enable_if_t<std::is_convertible_v<
	decltype(std::declval<T&>() < std::declval<T&>()), bool>>> :
	std::true_type{};

template<typename T>
struct is_nothrow_lessthan_comparable :
	std::bool_constant<noexcept(is_lessthan_comparable<T>::value)>
{
};

template<typename T>
struct is_comparable :
	std::bool_constant<is_equality_comparable<T>::value and is_lessthan_comparable<T>::value> {};

template<typename T>
struct is_nothrow_comparable :
	std::bool_constant<noexcept(is_comparable<T>::value)>
{
};

} // namespace detail 

#pragma region Comparables
template<typename EqualityComparable> _NODISCARD _CONSTANT_VAR
is_equality_comparable_v{ detail::is_equality_comparable<EqualityComparable>::value };

template<typename EqualityComparable> _NODISCARD _CONSTANT_VAR
is_nothrow_equality_comparable_v{ detail::is_nothrow_equality_comparable<EqualityComparable>::value };

template<typename LessThanComparable> _NODISCARD _CONSTANT_VAR
is_lessthan_comparable_v{ detail::is_lessthan_comparable<LessThanComparable>::value };

template<typename LessThanComparable> _NODISCARD _CONSTANT_VAR
is_nothrow_lessthan_comparable_v{ detail::is_nothrow_lessthan_comparable<LessThanComparable>::value };

template<typename Comparable> _NODISCARD _CONSTANT_VAR
is_comparable_v{ detail::is_comparable<Comparable>::value };

template<typename Comparable> _NODISCARD _CONSTANT_VAR
is_nothrow_comparable_v{ detail::is_nothrow_comparable<Comparable>::value };
#pragma endregion

namespace detail {

template<typename NullablePointer>
struct is_nullable_pointer : std::bool_constant<(
	(is_nothrow_equality_comparable<NullablePointer>::value and std::is_nothrow_default_constructible_v<NullablePointer>) and
	(std::is_pointer_v<NullablePointer> or std::is_pointer_v<std::add_pointer_t<NullablePointer>>) and
	(std::is_nothrow_copy_constructible_v<NullablePointer> and std::is_nothrow_copy_assignable_v<NullablePointer>) and
	(std::is_nothrow_copy_assignable_v<NullablePointer> and std::is_nothrow_destructible_v<NullablePointer>))> {};

template<typename FunctionObject, typename ...Args>
struct is_function_object :
	std::bool_constant<std::is_object_v<FunctionObject> and std::is_invocable_v<FunctionObject, Args...>>
{
};

// Tests to make sure our types satisfy their standard counterparts
// It's a standard since everything follows the same logic

// http://en.cppreference.com/w/cpp/memory/unique_ptr
template<typename UniquePointer, typename ...Args>
struct is_unique_ptr : std::bool_constant<
	(is_nullable_pointer<typename UniquePointer::pointer>::value) and
	(is_function_object<typename UniquePointer::deleter_type, Args...>::value or
		std::is_function_v<std::remove_reference_t<typename UniquePointer::deleter_type>>) and
		(!std::is_copy_constructible_v<UniquePointer> and !std::is_copy_assignable_v<UniquePointer>)
>
{
};

} // namespace detail

#pragma region Concepts for std::unique_ptr
template<typename NullablePointer> _NODISCARD _CONSTANT_VAR
is_nullable_pointer_v{ detail::is_nullable_pointer<NullablePointer>::value };

template<typename FunctionObject, typename ...Args> _NODISCARD _CONSTANT_VAR
is_function_object_v{ detail::is_function_object<FunctionObject, Args...>::value };

template<typename UniquePointer, typename ...Args> _NODISCARD _CONSTANT_VAR
is_unique_ptr_v{ detail::is_unique_ptr<UniquePointer, Args...>::value };
#pragma endregion

} // namespace ra


#endif // !RA_TYPE_TRAITS_H
