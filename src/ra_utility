#ifndef RA_UTILITY_H
#define RA_UTILITY_H
#pragma once

#include <utility>
#include <string>

namespace ra {

template<typename SignedType, class = std::enable_if_t<std::is_signed_v<SignedType>>>
_NODISCARD inline constexpr auto to_unsigned(SignedType st) noexcept { return static_cast<std::make_unsigned_t<SignedType>>(st); }

template<typename UnsignedType, class = std::enable_if_t<std::is_unsigned_v<UnsignedType>>>
_NODISCARD inline constexpr auto to_signed(UnsignedType st) noexcept { return static_cast<std::make_signed_t<UnsignedType>>(st); }

#if _WIN32
using float_type = float;
#elif _WIN64
using float_type = double;
#else
using float_type = long double; // should we even care bout this?
#endif // _WIN32

#if UNICODE
using TCHAR = wchar_t;
#else
using TCHAR = char;
#endif // UNICODE



using tstring = std::basic_string<TCHAR>;
template<typename Arithmetic, class = std::enable_if_t<std::is_arithmetic_v<Arithmetic>>>
_NODISCARD tstring to_tstring(Arithmetic a) noexcept
{
#ifdef UNICODE
	return std::to_wstring(a);
#else
	return std::to_string(a);
#endif // UNICODE
} // end function to_tstring



// testing to see if it will return float if deduced to double
template<typename Integral, class = std::enable_if_t<std::is_integral_v<Integral>>>
_NODISCARD constexpr auto to_floating(Integral i) noexcept
{
#if _WIN32
	return static_cast<float>(i);
#elif _WIN64
	return static_cast<double>(i);
#else
	return static_cast<long double>(i);
#endif // _WIN32
}

template<typename FloatingPoint, class = std::enable_if_t<std::is_floating_point_v<FloatingPoint>>>
_NODISCARD constexpr auto ftoi_unsigned(FloatingPoint fp) noexcept
{
#if _WIN32
	using return_type = decltype(to_unsigned(std::lroundf(FloatingPoint{})));
	return static_cast<return_type>(std::lroundf(fp));
#elif _WIN64
	using return_type = decltype(to_unsigned(std::llround(FloatingPoint{})));
	return static_cast<return_type>(std::llround(fp));
#else
	using return_type = decltype(to_unsigned(std::llroundl(FloatingPoint{})));
	return static_cast<return_type>(std::llroundl(fp));
#endif // _WIN32
}

template<typename FloatingPoint, class = std::enable_if_t<std::is_floating_point_v<FloatingPoint>>>
_NODISCARD constexpr auto ftoi_signed(FloatingPoint fp) noexcept
{
	// we could use intptr_t or ptrdiff_t but it might look confusing for some people
#if _WIN32
	return std::lroundf(fp);
#elif _WIN64
	return std::llround(fp);
#else
	return std::llroundl(fp);
#endif // _ARCH
}

template<typename Arithmetic, class = std::enable_if_t<std::is_arithmetic_v<Arithmetic>>>
_NODISCARD constexpr auto sqr(Arithmetic a) noexcept
{
	return std::pow(a, 2);
}

} // namespace ra


#endif // !RA_UTILITY_H
