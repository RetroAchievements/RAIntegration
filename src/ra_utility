#ifndef RA_UTILITY_H
#define RA_UTILITY_H
#pragma once

#include <utility>
#include <string>
#include <ra_fwd>

namespace ra {

template<typename SignedType, class = std::enable_if_t<std::is_signed_v<SignedType>>> _NODISCARD _CONSTANT_FN
to_unsigned(SignedType st) noexcept { return static_cast<std::make_unsigned_t<SignedType>>(st); }

template<typename UnsignedType, class = std::enable_if_t<std::is_unsigned_v<UnsignedType>>> _NODISCARD _CONSTANT_FN
to_signed(UnsignedType st) noexcept { return static_cast<std::make_signed_t<UnsignedType>>(st); }

using tstring = std::basic_string<TCHAR>;
template<typename Arithmetic, class = std::enable_if_t<std::is_arithmetic_v<Arithmetic>>> _NODISCARD inline
tstring to_tstring(Arithmetic a) noexcept
{
#if _MBCS
	return std::to_string(a);
#else
	return std::to_wstring(a);
#endif // _MBCS
} // end function to_tstring



// testing to see if it will return float if deduced to double
template<typename Integral, class = std::enable_if_t<std::is_integral_v<Integral>>> _NODISCARD _CONSTANT_FN
to_floating(Integral i) noexcept
{
#if _WIN32
	return static_cast<float>(i);
#else
	return static_cast<double>(i);
#endif // _WIN32
}

template<typename FloatingPoint, class = std::enable_if_t<std::is_floating_point_v<FloatingPoint>>>
_NODISCARD _CONSTANT_FN ftoi(FloatingPoint fp) noexcept
{
#if _WIN32
	if (std::signbit(fp))
		return std::lround(fp);

	return to_unsigned(std::lround(fp));
#else
	if (std::signbit(fp))
		return std::llround(fp);

	return to_unsigned(std::llround(fp));
#endif // _WIN32
}

template<typename Arithmetic, class = std::enable_if_t<std::is_arithmetic_v<Arithmetic>>> _NODISCARD _CONSTANT_FN
sqr(Arithmetic a) noexcept { return std::pow(a, 2); }

} // namespace ra


#endif // !RA_UTILITY_H
