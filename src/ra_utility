#ifndef RA_UTILITY_H
#define RA_UTILITY_H
#pragma once

#include <utility>
#include <string>

#if _HAS_CXX17
#ifndef _CONSTANT_VAR
#define _CONSTANT_VAR inline constexpr auto
#endif // !_CONSTANT_VAR
#else
#ifndef _CONSTANT_VAR
#define _CONSTANT_VAR constexpr auto
#endif // !_CONSTANT_VAR
#endif // _HAS_CXX17

#ifndef _CONSTANT_FN
#define _CONSTANT_FN _CONSTANT_VAR
#endif // !_CONSTANT_FN

namespace ra {

template<typename SignedType, class = std::enable_if_t<std::is_signed_v<SignedType>>>
_NODISCARD _CONSTANT_FN to_unsigned(SignedType st) noexcept { return static_cast<std::make_unsigned_t<SignedType>>(st); }

template<typename UnsignedType, class = std::enable_if_t<std::is_unsigned_v<UnsignedType>>>
_NODISCARD _CONSTANT_FN to_signed(UnsignedType st) noexcept { return static_cast<std::make_signed_t<UnsignedType>>(st); }

#if ARCH == 32
using float_type = float;
#elif ARCH == 64
using float_type = double;
#else
using float_type = long double; // should we even care bout this?
#endif // _WIN32

#if _MBCS
using TCHAR = char;
#else
using TCHAR = wchar_t;
#endif // UNICODE



using tstring = std::basic_string<TCHAR>;
template<typename Arithmetic, class = std::enable_if_t<std::is_arithmetic_v<Arithmetic>>>
_NODISCARD tstring to_tstring(Arithmetic a) noexcept
{
#if _MBCS
	return std::to_string(a);
#else
	return std::to_wstring(a);
#endif // UNICODE
} // end function to_tstring



// testing to see if it will return float if deduced to double
template<typename Integral, class = std::enable_if_t<std::is_integral_v<Integral>>>
_NODISCARD _CONSTANT_FN to_floating(Integral i) noexcept { return std::fabs(i); }

template<typename FloatingPoint, class = std::enable_if_t<std::is_floating_point_v<FloatingPoint>>>
_NODISCARD _CONSTANT_FN ftol(FloatingPoint fp) noexcept
{
	if(std::signbit(fp)) // fp is signed
	{
#if ARCH == 32
		return std::lroundf(fp);
#elif ARCH == 64
		return std::llround(fp);
#else
		return std::llroundl(fp);
#endif // _WIN32
	}
#if ARCH == 32
	return ra::to_unsigned(std::lroundf(fp));
#elif ARCH == 64
	return ra::to_unsigned(std::llround(fp));
#else
	return ra::to_unsigned(std::llroundl(fp));
#endif // ARCH
}


template<typename Arithmetic, class = std::enable_if_t<std::is_arithmetic_v<Arithmetic>>>
_NODISCARD _CONSTANT_FN sqr(Arithmetic a) noexcept { return std::pow(a, 2); }

} // namespace ra


#endif // !RA_UTILITY_H
